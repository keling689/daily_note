<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<script>
			// promise里只有一个参数，叫executor(执行器)
			function Promise(executor) {
				let self = this;
				self.status = 'pending'; //等待态
				self.value = undefined; //默认成功的值
				self.err = undefined; //默认失败的值
				self.onResolvedCallbacks = []; // 存放then成功的回调
				self.onRejectedCallbacks = []; // 存放then失败的回调
				function resolve(value) {
					if (self.status === 'pending') {
						self.status = 'resolved';
						self.value = value;
						self.onResolvedCallbacks.forEach(function(fn) {
							fn();
						});
					}
				}

				function reject(err) {
					if (self.status === 'pending') {
						self.status = 'rejected';
						self.err = err;
						self.onRejectedCallbacks.forEach(function(fn) {
							fn();
						});
					}
				}
				try { //捕获时发生异常，直接变成reject态，抛出错误
					executor(resolve, reject); //promise实例创建后，立即执行
				} catch (error) {
					reject(error);
				}
			}

			function resolvePromise(promise2, x, resolve, reject) {
				if (promise2 === x) { //promise2和x不能相同
					return reject(new TypeError('循环引用了'))
				}
				let called; // 表示是否调用过成功或者失败
				//这里对x的类型进行判断
				if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
					try { // 判断x是不是promise，如果x是对象并且x的then方法是函数我们就认为他是一个promise
						let then = x.then;
						if (typeof then === 'function') {
							then.call(x, function(y) {
								if (called) return
								called = true
								// y可能还是一个promise，在去解析直到返回的是一个普通值
								resolvePromise(promise2, y, resolve, reject)
							}, function(err) { //失败
								if (called) return
								called = true
								reject(err);
							})
						} else {
							resolve(x)
						}
					} catch (e) {
						if (called) return
						called = true;
						reject(e);
					}
				} else { // 说明是一个普通值1
					resolve(x); // 表示成功了
				}
			}
			//在prototype上定义then实例方法
			Promise.prototype.then = function(onFulfilled, onRejected) {
				onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : function(value) {
					return value;
				}
				onRejected = typeof onRejected === 'function' ? onRejected : function(err) {
					throw err; //这里需要抛出错误，不能return err，否则会在下一次调用成功态
				}
				let self = this;
				let promise2; //返回的promise
				if (self.status === 'resolved') {
					promise2 = new Promise(function(resolve, reject) {
						setTimeout(function() {
							try {
								let x = onFulfilled(self.value);
								resolvePromise(promise2, x, resolve, reject);
							} catch (e) {
								reject(e);
							}
						})
					})
				}
				if (self.status === 'rejected') {
					promise2 = new Promise(function(resolve, reject) {
						setTimeout(function() {
							try {
								let x = onRejected(self.err);
								resolvePromise(promise2, x, resolve, reject);
							} catch (e) {
								reject(e);
							}
						})

					})
				}
				// 当调用then时可能没成功 也没失败
				if (self.status === 'pending') {
					promise2 = new Promise(function(resolve, reject) {
						// 此时没有resolve 也没有reject
						self.onResolvedCallbacks.push(function() {
							setTimeout(function() {
								try {
									let x = onFulfilled(self.value);
									resolvePromise(promise2, x, resolve, reject);
								} catch (e) {
									reject(e)
								}
							})
						});
						self.onRejectedCallbacks.push(function() {
							setTimeout(function() {
								try {
									let x = onRejected(self.err);
									resolvePromise(promise2, x, resolve, reject);
								} catch (e) {
									reject(e);
								}
							})
						});
					})
				}
				return promise2;
			}
			Promise.defer = Promise.deferred = function() {
				let dfd = {};
				dfd.promise = new Promise(function(resolve, reject) {
					dfd.resolve = resolve;
					dfd.reject = reject;
				});
				return dfd
			}

			module.exports = Promise;
		</script>
	</body>
</html>
